> 根据ECMA规范 所有javascript的实现都应该有一个顶级的对象 其中浏览器的是window，node的是global

## 数据类型

### 基础数据类型
1. 数值(number)
2. 字符串(string)
3. 布尔(boolean)
4. null(object)
5. undefined(undefined)

### 引用(对象)数据类型
1. 对象(object)
  - 狭义对象(object)
  - 数组(array)
  - 函数(function)

### 特性
1. 基础数据类型直接指向**数据本体**，引用(对象)数据类型直接指向**数据的内存地址**。所以当赋值时，实际上基础类型是**复制一个本体给新变量**，而引用类型是复制了**内存地址给新变量**。这造成基础类型的新变量修改时**不会影响原来的变量**，而引用数据类型**会影响原来的变量**。
2. **函数(function)** 是一个非常特殊的对象，它不仅可以实例新的对象，而且所有构造方法的 **\_\_porto\_\_** 都指向他的**prototype**,包括他自己（他自己也是构造方法）和**Object**。总结一下，所有构造方法的原型都指向**函数(function)**的**prototype**。其他普通对象的原型指向，实例他们的构造方法的**prototype**。
3. **函数(function)** 的闭包其实就是一个接口函数，函数外部作用域（window）无法访问函数内部的作用域 **（内部作用域可以访问外部作用域，反之则不行。）** ，此时函数可以**返回另一个函数**（此函数内部写有相关方法访问它父级函数的内容，），外部作用域（window）可以通过调用这个返回的函数**间接访问**到，它父级的作用域。做到了外部作用域间接访问内部作用域的功能。而这个在父函数内部**返回的函数**就叫做**闭包**（使外部作用域间接访问内部作用域），当然不管它被不被返回都叫**闭包**。只是不返回的话好像没什么用。
4. 原型链图解：<img src="/md/img/原型链.png">

## 运算符

### 算术运算符

```javascript
x + y //加法运算符
x - y //减法运算符
x * y //乘法运算符
x / y //除法运算符
x ** y //指数运算符
x % y //余数运算符
++x,x++ //自增运算符
--x,x-- //自减运算符
+x //数值运算符
-x //负数值运算符
```

### 特性
1. 运算符优先级时是，先乘除后加减，相同的从左往右。
2. **加法运算符**拥有**连接运算符**的功能，当运算子中存在字符串基础类型时就会重载成**连接运算符**，并且之后同一个**链式**内的所有**加法运算符**都会重载成**连接运算符**。  
3. 当运算子为**对象**时，首先调用 **valueOf()** 实例方法，然后调用 **toString()** 实例方法，其返回结果再进行基础数据类型运算。所以可以根据此特性，重新定义这两个方法达到想要的效果。

### 比较运算符

```javascript
> //大于运算符
< //小于运算符
<= //小于或等于运算符
>= //大于或等于运算符
== //相等运算符
=== //严格相等运算符
!= //不相等运算符
!== //严格不相等运算符
```

### 特性
1. 大于，小于运算符中，如果两个运算子都是字符串则将比较它们的Unicode 码点。否则一律转换为数值基础类型进行比较。
2. 大于，小于运算符中，当运算子为**对象**时，首先调用 **valueOf()** 实例方法，然后调用 **toString()** 实例方法，其返回结果再进行基础数据类型运算。所以可以根据此特性，重新定义这两个方法达到想要的效果。
3. 相等，不相等运算符中，如果运算子**都**为**对象**则会比较是否指向同一个内存地址。
4. 相等，不相等运算符中，如果运算子**之一**为**对象**则会先转换成基础数据类型运算子的类型再进行比较。
5. undefined和null与自身严格相等。**var v1** 变量声明后默认值是undefined。

### 布尔运算符

```javascript
! //取反运算符
&& //且运算符
|| //或运算符
?: //三元运算符
```

### 特性
1. **&&** 且运算符中，如果前一个运算子为**true**则返回**后**一个运算子的值。反之为**false**则返回**前**一个的值，并且不对第二个求值。且运算符某些时候可以取代if语句。
2. **||** 或运算符中，如果前一个运算子为**true**则返回**前**一个运算子的值，并且不对第二个求值。反之为**false**则返回**后**一个的值。且运算符某些时候可以为变量设置默认值。
3. **?:** 三元运算符中，如果第一个运算子为**true**，,则返回第二个运算子的值，反之为**false**，则返回第三个运算子的值。

### 其他运算符

```javascript
void(0) //void运算符
, //逗号运算符
... //扩展运算符（ES6新增）
```

### 特性
1. **void()** void运算符中，执行一个表达式。通常用在a标签防止跳转。
2. **,** 逗号运算符中，执行所有运算子，但只返回最后一个运算子的值。
3. **...** 扩展运算符中，其主要功能为将可遍历结构（数组，对象）将其中的元素提取出来。其中对象的元素是成对出现的，并且无法脱离花括号。所以对象的元素只能提取到其他的对象中。无法直接提取给变量。

### 二进制位运算符(位运算符)

https://wangdoc.com/javascript/operators/bit.html

### 内部对象

## Array
```javascript
//修改器方法
Array.prototype.shift() //开头删除一个值，并返回这个值。
Array.prototype.pop() //末尾删除一个值，并返回这个值。
Array.prototype.unshift() //开头增加一个或多个值，并返回新的length。
Array.prototype.push() //末尾增加一个或多个值，并返回新的length。
Array.prototype.splice() //对任意位置的值进行，增删改操作，并返回被删除的值。其他情况返回空数组。
Array.prototype.reverse() //颠倒数组。返回被颠倒的数组。和原数组相等。
Array.prototype.sort() //对数组进行排序。返回被排序的数组。和原数组相等。

//访问方法
Array.prototype.concat() //合并数组。
```

## 特性
1. 所有**实例的Array**都有一个自动添加的**length属性**注意它不是原型属性所以他是实例数组的**私有属性**，表示当前数组有多少个值。注意不要和**Array.prototype.length**和**Array.length**搞混。**Array.prototype.length**在实例中存在于 **\_\_proto\_\_** 中。而**Array.length**是属于**Array构造方法的静态属性**。