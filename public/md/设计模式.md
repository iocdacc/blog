## 设计模式七大原则
1. 开闭原则: 软件实体应当对扩展开放，对修改关闭.
2. 里氏替换原则: 子类不要修改或重新定义父类的方法.
3. 依赖倒置原则: 不要直接实例化依赖,应该实例化形参,把依赖传进来. 之后衍生出了更加完善的原则,控制反转和依赖注入.
    - 控制反转: 根本就不要实例化依赖,依赖应该直接由外部实例化后传入直接使用.使用方不要实例依赖.
    - 依赖注入: 不要直接在外面实例化依赖,应该有专门的方法来做实例化依赖这件事情.
4. 单一职责原则: 类和模块因该只做一类事情. 至于怎么分类很考验程序设计者的能力.
5. 接口隔离原则: 类似于单一职责原则,接口应该只定义一类方法,因为如果定义多个类别的方法,那继承接口的方法不得不实现多个类别的方法而违反了单一职责原则.
6. 最少知识原则: 类和模块应该尽量少的直接调用或者直接依赖.应该用一个中转类间接调用和依赖.
7. 合成复用原则: 尽量使用依赖实现类之间的联系,而不是继承.

## 单例模式

> 类只创建一个实例,重复实例化时返回第一个实例.  
> 主要作用为减少内存使用  

```javascript
//懒汉单例
//第一次实例时创建第一个实例
function A(){
  this.name = 'A'
}
let B = (function(){
  let a = null
  return function (){
    if (!a){
      a = new A()
    }
    return a
  }
})()

B() === B() //true

//饿汉单例
//类加载时就创建第一个实例
function A(){
  this.name = 'A'
}
let B = (function(){
  let a = new A()
  return function (){
    return a
  }
})()

B() === B() //true
```

## 策略模式

> 将代码用映射关联封装,通过映射关系调用代码  
> 增加复用性,可维护性  

```javascript
let fn = {
  a: ()=>{return 'fun a'},
  b: ()=>{return 'fun b'},
  c: ()=>{return 'fun c'},
}

function call(key){
  return fn[key] ? fn[key]() : null
}

call('a') //'fun a'
call('b') //'fun b'
call('c') //'fun c'
call('d') //null
```

## 代理模式

> 通过一个代理函数间接访问主函数
> 简化主函数,将繁琐的判断,缓存,预处理分离出来.主函数只进行核心业务.增加可维护性.
> 单一职责原则

```javascript
//保护代理
function funa(a, b){
  //只有当实参都为数字5时才能执行
  return a + b
}

function funb(a, b){
  if(a !== 5 || b !== 5) return '非法参数'
  return funa(a, b)
}

funb(5, 5) //10
funb('5', '5') //非法参数
funb(111, 222) //非法参数

//预处理代理
function funa(a, b){
  //a加15,b加10然后进行计算
  return a + b
}

function funb(a, b){
  a = a + 15
  b = b + 10
  return funa(a, b)
}

funb(1, 1) //27
funb(10, 5) //40

//缓存代理
function funa(a, b){
  //普通加法运算
  return a + b
}

let funb = (function (){
  let cache = {}
  return function (a, b){
    if (cache[`${a},${b}`]){
      return '我是缓存:' + cache[`${a},${b}`]
    }else{
      cache[`${a},${b}`] = funa(a, b)
      return cache[`${a},${b}`]
    }
  }
})()

funb(100, 1000) //1100
funb(100, 1000) //我是缓存:1100
funb(100, 1000) //我是缓存:1100
funb(100, 1000) //我是缓存:1100
```

## 迭代器模式

>通过一个抽象的方法遍历一个数据集合.  
>这个抽象方法应该遵循统一的规范对外返回一样的API,让遍历不同集合的操作相同.  
>ES6开始javascript内部可遍历集合基本都集成了迭代器接口(Symbol.iterator)它们的API都是统一了  
>迭代器模式的应用除了javascript集合自带的普通迭代器,其实也可以自定义特殊迭代器来达到特殊业务需求.  
>一般来说自定义迭代器也应该遵循ES6的规范.  

```javascript
//Array String Map Set arguments Typed Arrays Generators
//可迭代对象都有默认的迭代器,并遵守ECMA迭代规范
let arr = [1,2,3]
let arrIterator = arr[Symbol.iterator]() //返回迭代对象
arrIterator.next() //执行迭代方法

//自定义迭代方法
arr[Symbol.iterator] = function(){}
```

## 发布-订阅模式(观察者模式)

>将一个回调函数绑定到某个状态上,当状态成立时执行这个回调函数.

```javascript
//自定义发布订阅函数
//当状态成立时代码执行发布方法,发布方法执行回调函数.
let callback = function (){
  console.log('callback start')
}

let userEvent = {
  subscribes: {},
  subscribe: function(event, callback){
    this.subscribes[event] = this.subscribes[event] ? this.subscribes[event].push(callback) : [callback]
  },
  publish: function(event){
    this.subscribes[event].forEach(function (fn){
      fn()
    })
  }
}

userEvent.subscribe('A', callback) //订阅事件
userEvent.publish('A') //发布事件 callback start

//直接订阅浏览器提供的事件
//当点击事件成立时会执行回调函数
let callback = function (){
  console.log(123)
}
window.onclick = callback

//也可以使用浏览器自带的方法自定义发布订阅函数
//需要注意这些构造方法只有浏览器环境提供
Event,CustomEvent,EventListener,dispatchEvent,fireEvent

```

## 命令模式

>不直接执行方法,而是通过另一个方法间接调用要执行的方法  
>而且间接调用不是马上执行,而是把一系列命令先缓存起来.然后调用执行方法,统一执行这一系列命令.  
>在调用执行方法之前可以增加,删除,修改命令.  

```javascript
//简单的命令模式
let command = {
  concreteCommand:{ //可执行的命令
    'funb': function (){
      b()
    },
    'func': function (){
      c()
    }
  },
  commands: [], //已发出但未执行的命令
  set: function (commandFun){ //发出命令
    if (!this.concreteCommand[commandFun]) {
      return false
    } 
    this.commands.push(this.concreteCommand[commandFun])
    return this.commands.length - 1
  },
  remove: function (commandId){ //撤销命令
    this.commands[commandId] = function (){}
  },
  exec: function (){ //执行命令
    this.commands.forEach(function (fn){
      fn()
    })
    this.commands = []
  }
}

function a(){
  let funb = command.set('funb')
  let func = command.set('func')
  command.remove(funb)
  command.exec()
}

function b(){
  console.log('function b被执行了')
}

function c(){
  console.log('function c被执行了')
}
```