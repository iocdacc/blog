> 根据ECMA规范 所有javascript的实现都应该有一个顶级的对象 其中浏览器的是window，node的是global

## 数据类型

### 基础数据类型
1. 数值(number)
2. 字符串(string)
3. 布尔(boolean)
4. null(object)
5. undefined(undefined)

### 引用(对象)数据类型
1. 对象(object)
  - 狭义对象(object)
  - 数组(array)
  - 函数(function)

基础数据类型直接指向**数据本体**  
引用(对象)数据类型直接指向**数据的内存地址**  
所以当赋值时，实际上基础类型是**复制一个本体给新变量**，而引用类型是复制了**内存地址给新变量**。  
这造成基础类型的新变量修改时**不会影响原来的变量**，而引用数据类型**会影响原来的变量**。

## 运算符

### 算术运算符
1. 加|减|乘|除运算符(+ - * %)
``` js
  a + b
  a - b
  a * b
  a / b
```
其中加运算符如果有一个运算子为字符串(string) 会将另一个运算子转换成字符串然后执行链接运算符
2. 指数运算符(x ** y) //前一个运算子是底数，后一个运算子是指数
``` js
  2 ** 3 // 8
```
3. 余数运算符(x % y) //前一个运算子除后一个运算子余下的数
``` js
  2 % 10 // 2
  10 % 2 // 0
  10 % 3 // 1
```
可以看作分数，前一个运算子是分子，后一个运算子是分母。真分数状态下的分子就是余数。
4. 自增|自减运算符(++x|x++|--x|x--)
``` js
  var a = 1
  var b = a++
  b //1
  var a = 1
  var b = ++a
  b //2
```
区别在于先赋值再自增还是先自增再赋值
5. 正负数值运算符(+x|-x) // 可以将其他类型的值转换成数值
``` js
  +true // 1
  +[] // 0
  +{} // NaN
  var x = 1;
  -x // -1
  -(-x) // 1
``` 
6. 赋值运算符(var x = 1;) // 赋值运算符还可以与其他运算符结合，形成变体
``` js
// 将 1 赋值给变量 x
var x = 1;
// 将变量 y 的值赋值给变量 x
var x = y;
// 等同于 x = x + y
x += y
// 等同于 x = x - y
x -= y
// 等同于 x = x * y
x *= y
// 等同于 x = x / y
x /= y
// 等同于 x = x % y
x %= y
// 等同于 x = x ** y
x **= y
```
除引用数据类型外的其他基础数据类型会先转换成数值再进行运算
除赋值运算符所有算术运算符都有此特性：  
如果运算子是，引用(对象)数据类型，会先调用this.valueOf()然后调用this.toString()再进行运算  
所以可以自定义这两个对象方法 达到自己的目的

### 比较运算符
1. 大于，小于，小于或等于，大于或等于  
字符串的比较 是比较Unicode码点  
``` js
// 字符串按照字典顺序进行比较。
'cat' > 'dog' // false
'cat' > 'catalog' // false
//JavaScript 引擎内部首先比较首字符的 Unicode 码点。如果相等，再比较第二个字符的 Unicode 码点，以此类推。
'cat' > 'Cat' // true'
//上面代码中，小写的c的 Unicode 码点（99）大于大写的C的 Unicode 码点（67），所以返回true。
//由于所有字符都有 Unicode 码点，因此汉字也可以比较。
'大' > '小' // false
//上面代码中，“大”的 Unicode 码点是22823，“小”是23567，因此返回false。
```
非字符串的其他基础数据 类型比较 是先转成数值再比较  
``` js
5 > '4' // true
// 等同于 5 > Number('4')
// 即 5 > 4

true > false // true
// 等同于 Number(true) > Number(false)
// 即 1 > 0

2 > true // true
// 等同于 2 > Number(true)
// 即 2 > 1

2 > null // true
// 等同于 2 > Number(null)
// 即 2 > 0

2 > undefined // false
// 等同于 2 > Number(undefined)
// 即 2 > NaN
```
这里需要注意与NaN的比较。任何值（包括NaN本身）与NaN比较，返回的都是false  

比较运算符都有此特性：    
如果运算子是，引用(对象)数据类型，会先调用this.valueOf()然后调用this.toString()再进行运算    
所以可以自定义这两个对象方法 达到自己的目的

2. 严格相等，严格不相等，相等，不相等运算符  
严格相等,两个值的类型不同，直接返回false
``` js
1 === "1" // false
true === "true" // false
1 === 0x1 // true
NaN === NaN  // false
+0 === -0 // true
//两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个地址。
{} === {} // false
[] === [] // false
(function () {} === function () {}) // false
undefined === undefined // true
null === null // true
```
注意，对于两个对象的比较，严格相等运算符比较的是地址，而大于或小于运算符比较的是值。  
严格相等运算符有一个对应的“严格不相等运算符”（!==），它的算法就是先求严格相等运算符的结果，然后返回相反值。  
相等运算符用来比较相同类型的数据时，与严格相等运算符完全一样。  
比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。下面分成四种情况，讨论不同类型的值互相比较的规则。  
基础数据类型的值**会转换成数值**再进行比较  
对象（这里指广义的对象，包括数组和函数）与原始类型的值比较时，对象转换成原始类型的值，再进行比较。  
因为基础数据类型会先转换成数值，所以会带来一些违反直觉的结果
``` js
0 == ''             // true
0 == '0'            // true

2 == true           // false
2 == false          // false

false == 'false'    // false
false == '0'        // true

false == undefined  // false
false == null       // false
null == undefined   // true

' \t\r\n ' == 0     // true
```
上面这些表达式都不同于直觉，很容易出错。因此建议不要使用相等运算符（==），最好只使用严格相等运算符（===）。

### 布尔运算符

### 二进制位运算符(位运算符)

### 其他运算符